#!/usr/bin/env bash
#
# Slugify files or strings
#
# Usage:
#   slugify file1 file2 ...           # Rename files
#   slugify -s "String to slugify"    # Slugify a string
#   echo "text" | slugify             # Slugify from stdin
#

set -euo pipefail

if [[ $(uname) == 'Darwin' ]]; then
  mv=/bin/mv
else
  mv='mv'
fi

# Function to perform the slugification
slugify_text() {
  local output="$1"

  # Remove some characters.
  output=$(echo "$output" | tr -d \'\"\!\(\)\®)

  # Replace other punctuation with dashes.
  output=${output//[,;:]/-}

  # PascalCase to lisp-case.
  output=$(echo "$output" | perl -pe 's/([a-z0-9])([A-Z])/$1_\L$2/g')

  # Remove newlines.
  output=$(echo "$output" | tr -d '\n')

  # Compress spaces.
  output=$(echo "$output" | tr -s ' ')

  # Endash+emdash to dash.
  output=${output//–/-}
  output=${output//–/-}

  # Underscores to dash.
  output=${output//_/-}

  # Plus to dash.
  output=${output//+/-}

  # Remove spaces next to dashes.
  output=${output//- /-}
  output=${output// -/-}

  # Spaces to dashes
  output=$(echo "$output" | tr ' ' '-')

  # lowercase
  output=${output,,}

  echo "$output"
}

# Parse arguments
string_mode=false
if [[ "${1:-}" == "-s" ]] || [[ "${1:-}" == "--string" ]]; then
  string_mode=true
  shift
fi

# Handle stdin (no arguments)
if [[ $# -eq 0 ]]; then
  while IFS= read -r line; do
    slugify_text "$line"
  done
  exit 0
fi

# String mode - just output slugified strings
if [[ "$string_mode" == true ]]; then
  for text in "$@"; do
    slugify_text "$text"
  done
  exit 0
fi

# File mode - rename files
for file_path in "$@"; do
  output=$(slugify_text "$file_path")
  
  if [[ "$file_path" != "$output" ]]; then
    $mv -iv "${file_path}" "${output}"
  fi
done
